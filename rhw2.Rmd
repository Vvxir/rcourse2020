---
title: "rhw2"
author: "Beini"
date: "2020/7/13"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##  Homework 2

1. *Loading and cleaning*
-------------------------

a. Load the data into a dataframe called `ca_pa`.
    ```{r}
library(DAAG)
library(lattice)
ca_pa <- read.csv("/Users/zhaobeini/github/rcourse2020/data/calif_penn_2011.csv",header=T,sep = ",")
```
b. How many rows and columns does the dataframe have?
    ```{r}
nrow(ca_pa)
ncol(ca_pa)
```
c. Run this command, and explain, in words, what this does: colSums(apply(ca_pa,c(1,2),is.na))
    ```{r}
colSums(apply(ca_pa,c(1,2),is.na))
```
**Conclusion:** The `apply(ca_pa,c(1,2),is.na)` function is used to check whether data in `ca_pa` is NA or not. `c(1,2)` indicates the function will be applied to all rows and columns. If there is missing data NA, the function would return TRUE, else FALSE. Finally, colSums() sums all the columns and return the total number of missing data of each column in `ca_pa`.
d. The function `na.omit()` takes a dataframe and returns a new dataframe, omitting any row containing an NA value.  Use it to purge the data set of rows with incomplete data.
    ```{r}
ca_pa2 <- na.omit(ca_pa)
```
e. How many rows did this eliminate?
    ```{r}
nrow(ca_pa)-nrow(ca_pa2)
```
f. Are your answers in (c) and (e) compatible? Explain.
**Conclusion:**  `na.omit()` function deletes rows with incomplete data in `ca_pa`. The result in (c) represents the total number of NA data of every column, while (e) shows how many rows have NA data. Because there could be more than one NA data in every rows, these two outcomes do not have a direct connection and they are not necessarily equal.

2. *This Very New House*
-------------------------

a. The variable `Built_2005_or_later` indicates the percentage of houses in each Census tract built since 2005. Plot median house prices against this variable.
    ```{r}
plot(ca_pa[["Built_2005_or_later"]],ca_pa[["Median_house_value"]],
     ylab="Median house value",
     xlab="House percentage Built 2005 or later",
     main="Prices against House persentage 2005 or later")
```
b. Make a new plot, or pair of plots, which breaks this out by state.  Note that the state is recorded in the `STATEFP` variable, with California being state 6 and Pennsylvania state 42.
```{r}
ca_pa_Cal<-ca_pa[ca_pa$STATEFP==6,]
plot(ca_pa_Cal$Median_house_value ~ ca_pa_Cal$Built_2005_or_later,
     xlab="House percentage Built 2005 or later",ylab="Median house value",
     main="House prices against Built_2005_or_later in California")

ca_pa_Pen<-ca_pa[ca_pa$STATEFP==42,]
plot(ca_pa_Pen$Median_house_value ~ ca_pa_Pen$Built_2005_or_later,
     xlab="House percentage Built 2005 or later",ylab="Median house value",
     main="House prices against Built_2005_or_later in Pennsylvania")
```    

3. *Nobody Home*
-------------------------
a. Add a new column to the dataframe which contains the vacancy rate. What are the minimum, maximum, mean, and median vacancy rates?
    ```{r}
vacancy_rate <- ca_pa$Vacant_units/ca_pa$Total_unit
ca_pa3 <- data.frame(ca_pa,vacancy_rate)
min(vacancy_rate,na.rm=TRUE)
max(vacancy_rate,na.rm=TRUE)
mean(vacancy_rate,na.rm=TRUE)
median(vacancy_rate,na.rm=TRUE)
```
b. Plot the vacancy rate against median house value.
    ```{r}
plot(ca_pa3[["vacancy_rate"]] ~ ca_pa3[["Median_house_value"]],
     ylab="vacancy rate", xlab="median house value",
     main="vacancy rate against median house value")
```
c. Plot vacancy rate against median house value separately for California and for Pennsylvania. Is there a difference?
    ```{r}
ca_pa3_Cal <- ca_pa3[ca_pa$STATEFP==6,]
ca_pa3_Pen <- ca_pa3[ca_pa$STATEFP==42,]
plot(ca_pa3_Cal[["vacancy_rate"]] ~ ca_pa3_Cal[["Median_house_value"]],
     ylab="vacancy rate", xlab="median house value",
     main="vacancy rate against median house value in California")
    
plot(ca_pa3_Pen[["vacancy_rate"]] ~ ca_pa3_Pen[["Median_house_value"]],
     ylab="vacancy rate", xlab="median house value",
     main="vacancy rate against median house value in Pennsylvania")
```

**Conclusion:**  Generally speaking, the vacancy rate of houses in California is more evenly distributed while the vacancy rate in Pennsylvania drops as the median house value increases.

4. *`COUNTYFP` Column*
----------------------

The column COUNTYFP contains a numerical code for counties within each state. We are interested in Alameda County (county 1 in California), Santa Clara (county 85 in California), and Allegheny County (county 3 in Pennsylvania).

a. Explain what the block of code at the end of this question is supposed to accomplish, and how it does it.
    ```{r}
acca <- c()
for (tract in 1:nrow(ca_pa)) {
  if (ca_pa$STATEFP[tract] == 6) {
    if (ca_pa$COUNTYFP[tract] == 1) {
      acca <- c(acca, tract)
    }
  }
}
accamhv <- c()
for (tract in acca) {
  accamhv <- c(accamhv, ca_pa[tract,10])
}
median(accamhv,na.rm = TRUE)
```
    **Conclusion:**  The block of code is aimed to find the median value of "Median_house_value" of Alameda County data. 
    
    First of all, it assigns an empty vector to `acca`, then it starts a for-loop to find data of California State by confirm if STATEFP==6. After that,we try to find data of Alameda County by check if COUNTYFP==1. Then add these data rows of Alameda County to `acca`. Use another for-loop structure to add the 10th column in `acca` to an empty vector `accamhv`. Finally, use `median()` function to get the median data. P.S. Change `median(accamhv)` to `median(accamhv,na.rm = TRUE)` because there is some NA data which should be ingored.

b. Give a single line of R which gives the same final answer as the block of code. Note: there are at least two ways to do this; you just have to find one.
    ```{r}
median(ca_pa[ca_pa$STATEFP==6 & ca_pa$COUNTYFP==1,10],na.rm=TRUE)
```
c. For Alameda, Santa Clara and Allegheny Counties, what were the average percentages of housing built since 2005?
    ```{r}
mean(ca_pa[(ca_pa$STATEFP==6 & ca_pa$COUNTYFP==1),16],na.rm=TRUE)
mean(ca_pa[(ca_pa$STATEFP==6 & ca_pa$COUNTYFP==85),16],na.rm=TRUE)
mean(ca_pa[(ca_pa$STATEFP==42 & ca_pa$COUNTYFP==3),16],na.rm=TRUE)
```
    **Conclusion:**  The average percentages of housing built since 2005 for Alameda, Santa Clara and Allegheny Counties are respectively `2.932778, 3.160215, 1.883375`.

d. The cor function calculates the correlation coefficient between two variables. What is the correlation between median house value and the percent of housing built since 2005 in (i) the whole data, (ii) all of California, (iii) all of Pennsylvania, (iv) Alameda County, (v) Santa Clara County and (vi) Allegheny County?
    ```{r}
cor(ca_pa2$Median_house_value,ca_pa2$Built_2005_or_later)   # the whole data
cor(ca_pa2[ca_pa2$STATEFP==6,10],ca_pa2[ca_pa2$STATEFP==6,16])  # California
cor(ca_pa2[ca_pa2$STATEFP==42,10],ca_pa2[ca_pa2$STATEFP==42,16])  # Pennsylvania
cor(ca_pa2[ca_pa2$STATEFP==6 & ca_pa2$COUNTYFP==1,10],
    ca_pa2[ca_pa2$STATEFP==6 & ca_pa2$COUNTYFP==1,16])  # Alameda County
cor(ca_pa2[ca_pa2$STATEFP==6 & ca_pa2$COUNTYFP==85,10],
    ca_pa2[ca_pa2$STATEFP==6 & ca_pa2$COUNTYFP==85,16])   # Santa Clara County
cor(ca_pa2[ca_pa2$STATEFP==42 & ca_pa2$COUNTYFP==3,10],
    ca_pa2[ca_pa2$STATEFP==42 & ca_pa2$COUNTYFP==3,16])  # Allegheny County
```
e. Make three plots, showing median house values against median income, for Alameda, Santa Clara, and Allegheny Counties. (If you can fit the information into one plot, clearly distinguishing the three counties, thatâ€™s OK too.)
    ```{r}
library(ggplot2)
df1 <- ca_pa2[ca_pa2$COUNTYFP==1 & ca_pa2$STATEFP==6|
              ca_pa2$COUNTYFP==85 & ca_pa2$STATEFP==6|
              ca_pa2$COUNTYFP==3 & ca_pa2$STATEFP==42,c(4,10,33)]
Median_income = df1[,3] 
Median_house_value = df1[,2]
df1[df1$COUNTYFP==1,"COUNTYFP"]<-c("Alameda")
df1[df1$COUNTYFP==85,"COUNTYFP"]<-c("Santa Clara")
df1[df1$COUNTYFP==3,"COUNTYFP"]<-c("Allegheny")
County= df1[,1]

ggplot(df1,aes(Median_income, Median_house_value, color = County))+
  geom_point()+
  labs(x="Median income",y="Median house value",title = "       Median House Values against Median Income")

```

MB.Ch1.11. 
-----------------
Run the following code and explain the output from the successive uses of table().
```{r}
gender <- factor(c(rep("female", 91), rep("male", 92)))
table(gender)
```
It assigns 91  "female" and 92 "male" objects to the `gender` vector, and the factor values are "female" and "male". The `table()` function sorts two factors as "female" first and "male" second, and then outputs the number of each factor.

```{r}
gender <- factor(gender, levels=c("male", "female"))
table(gender)
```
The `level()` function changes the order of two factors. Therefore, the "male" former becomes the former one and "female" becomes the latter.

```{r}
gender <- factor(gender, levels=c("Male", "female"))
# Note the mistake: "Male" should be "male"
table(gender)
```
It changes the factor to "Male" and "female", so `table(gender)` shows the number of "Male" and "female". The count of "Male" factor is 0.
```{r}
table(gender, exclude=NULL)
rm(gender)  # Remove gender
```
After we adds `exclude=NULL`, `rm(gender)` shows three factors including <NA>. The number of <NA> is 92. This is the number of "male" which is not listed in `levels` vector.

MB.Ch1.12. 
-----------
Write a function that calculates the proportion of values in a vector x that exceed some value cutoff.

(a) Use the sequence of numbers 1, 2, . . . , 100 to check that this function gives the result that is expected.
    ```{r}
pro<-function(x,num){
  return(sum(x>num)/length(x))
}
test<-seq(1,100)
pro(test,70)
pro(test,87)
```
(b) Obtain the vector ex01.36 from the Devore6 (or Devore7) package. These data give the times required for individuals to escape from an oil platform during a drill. Use dotplot() to show the distribution of times. Calculate the proportion of escape times that exceed 7 minutes.

MB.Ch1.18.
------------
The Rabbit data frame in the MASS library contains blood pressure change measurements on five rabbits (labeled as R1, R2, . . . ,R5) under various control and treatment conditions. Read the help file for more information. Use the unstack() function (three times) to convert Rabbit to the following form:

Treatment Dose R1 R2 R3 R4 R5

1 Control 6.25 0.50 1.00 0.75 1.25 1.5

2 Control 12.50 4.50 1.25 3.00 1.50 1.5
...

```{r}
library(MASS)
change1<-unstack(Rabbit,BPchange~Animal)
change2<-unstack(Rabbit,Dose~Animal)
change3<-unstack(Rabbit,Treatment~Animal)
change<-cbind(change3[1],change2[1],change1)
colnames(change)=c("Treatment","Dose","R1","R2","R3","R4","R5")
change
```
