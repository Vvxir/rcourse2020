---
title: "rhw1"
author: "Beini"
date: "2020/7/12"
output:
  html_document: default
  pdf_document: default
---

## Homework 1

**1. The Iowa data set iowa.csv is a toy example that summarises the yield of wheat (bushels per acre) for the state of Iowa between 1930-1962. In addition to yield, year, rainfall and temperature were recorded as the main predictors of yield.**

```{r}
iowa.df<-read.csv("/Users/zhaobeini/github/rcourse2020/data/Iowa.csv", header=T,sep = ";")
nrow(iowa.df)
ncol(iowa.df)
colnames(iowa.df)
iowa.df[5,7]
iowa.df[2,]
```
**Conclusions: ** 

+ b. iowa.df has 33 rows and 10 columns. 

+ c. The names of iowa.df are "Year"  "Rain0" "Temp1" "Rain1" "Temp2" "Rain2" "Temp3" "Rain3" "Temp4" "Yield".

+ d. The value of row 5, column 7 is 79.7.

+ e. The second row of iowa.df is displayed above.

**2. Syntax and class-typing.**
```{r}
vector1 <- c("5", "12", "7", "32")
typeof(vector1)
max(vector1)
sort(vector1)
```
**Conclusions:** 

+ **a1.** max(vector1) is "7" and sort(vector1) is "12" "32" "5"  "7". Because the type of vector1 is character, the comparison of them is lexicographic and they are translated to UTF-8 before comparision. The first letter of each character string are "5", "1", "7", "3" ,therefore, we can tell the order of them is "7">"5">"3">"1". Then we can come to the result of the order of character strings: "7">"5">"32">"12".

+ **a2.** sum(vectors) should apply to numeric vectors, and vector1 does not match the criteria.
```{r}
vector2 <- c("5",7,12)
vector2[2] 
typeof(vector2[2])
vector2[3]
typeof(vector2[3])
```
+ **b1.** In $x+y$, $x$, $y$ should be numeric objects or it could not be "+". The elements in vector should be the same, so every element after "5" would be character. And vector2[2]+vector2[3] comes to an error.
```{r}
dataframe3 <- data.frame(z1="5",z2=7,z3=12)
typeof(dataframe3[1,2])
typeof(dataframe3[1,3])
dataframe3[1,2] + dataframe3[1,3]
```
+ **b2.** Data frame can contain variable types of objects, therefore, the types of dataframe3[1,2] and dataframe3[1,3] are double and they can be "+".
```{r}
list4 <- list(z1="6", z2=42, z3="49", z4=126)
list4[[2]] + list4[[4]]
```
+ **b3.** list[ ] is used to access data in the list and the return result is a list which could not be added. list[[ ]] is used to get the specific data in the list as a vector. In the case of list4, we can get double object 42 and 126 so the sum is 168.

**3. Working with functions and operators.**

+ **a.** Design an expression that will give you the sequence of numbers from 1 to 10000 in increments of 372 and another that will give you a sequence between 1 and 10000 that is exactly 50 numbers in length.
```{r}
seq(1, 10000, by = 372)
seq(1, 10000, length.out = 50)
```
+ **b.** Explain the difference between rep(1:3,times=3) and rep(1:3, each=3).
```{r}
rep(1:3,times=3)
rep(1:3,each=3)
```
**Conclusions:** 

+ **a.** use `seq(1, 10000, by = 372)` and `seq(1, 10000, length.out = 50)`.

+ **b.** `rep(1:3,times=3)` means to repeat the whole vector "1:3" 3 times, while `rep(1:3,each=3)` means that each element of "1:3" is repeated 3 times.

**MB.Ch1.2. **

```{r}
library(DAAG)
df <- orings[c(1,2,4,11,13,18),]
plot(df[["Temperature"]],df[["Total"]],xlab="Temperature",ylab="Total Incidents")
```


```{r}
plot(orings[["Temperature"]],orings[["Total"]],xlab="Temperature",ylab="Total Incidents", main="Orings")
```

**MB.Ch1.4. **

+ **a.** Use the function str() to get information on each of the columns. Determine whether any of the columns hold missing values.
```{r}
str(ais)
resulttable<-rep(FALSE,ncol(ais))
for (i in 1:ncol(ais)){
  ais_na<-ais[is.na(ais[[i]])==FALSE,]
  if (nrow(ais)==nrow(ais_na)){
    resulttable[i]<-TRUE
  }
}
resulttable
```
+ **b.** Make a table that shows the numbers of males and females for each different sport. In which sports is there a large imbalance (e.g., by a factor of more than 2:1) in the numbers of the two sexes?

```{r}
library(DAAG)
library(ggplot2)
library(plyr)
ddply(ais,c("sex","sport"),summarise,N=length(sex))
ggplot(data=ais,aes(x=sport,fill=sex))+
geom_bar(position='dodge')
```

**Conclusions:** 

+ **a.** We can tell from the function `str()` that 1-11 columns hold numerical data, while the 12th column represents for their gender and the last column contains ten different names of sports. According to the analysis, there is no missing value in any of the columns.

+ **b.** Gym and Netball sports only have female participants while W_Polo only has male ones. Besides, T_Sprnt has 4 women and 11 men which is unbalanced in gender. P.S. the ggplot figure shows the result more directly.

**MB.Ch1.6. **

```{r}
lakes =matrix(c(217,254,248,254,253,227,178,207,217,24387,5374,4624,2247,1353,1223,1151,755,657),nrow=9)
row.names(lakes)<-c("Winnipeg","Winnipegosis","Manitoba","SouthernIndian","Cedar","Island","Gods","Cross","Playgreen")
colnames(lakes)<-c("elevation","area")
Manitoba.lakes <- data.frame(lakes)
Manitoba.lakes
```
+ **a.** Use the following code to plot log2(area) versus elevation, adding labeling information (there is an extreme value of area that makes a logarithmic scale pretty much essential):
```{r}
attach(Manitoba.lakes)
plot(log2(area) ~ elevation, pch=16, xlim=c(170,280))
# NB: Doubling the area increases log2(area) by 1.0
text(log2(area) ~ elevation, labels=row.names(Manitoba.lakes), pos=4)
text(log2(area) ~ elevation, labels=area, pos=2)
title("Manitoba's Largest Lakes")
```

captions that explain the labeling on the points and on the y-axis. It will be necessary to explain how distances on the scale relate to changes in area.

+ **b.** Repeat the plot and associated labeling, now plotting area versus elevation, but specifying log="y" in order to obtain a logarithmic y-scale.
```{r}
plot(area ~ elevation, pch=16, xlim=c(170,280), ylog=T)
text(area ~ elevation, labels=row.names(Manitoba.lakes), pos=4, ylog=T)
text(area ~ elevation, labels=area, pos=2, ylog=T)
title("Manitobaâ€™s Largest Lakes")
```

**Conclusions:** 

+ **a.** Generally speaking, when the elevation is below 220 meters, the area of lakes reduces as the elevation increase. when the elevation is above 220 meters, the area of lakes starts to drop as the elevation goes up. However, the Winnipeg is an exception with a relatively low elevation but a significantly large area.

**MB.Ch1.7. **
Look up the help page for the R function dotchart(). Use this function to display the areas of the Manitoba lakes (a) on a linear scale, and (b) on a logarithmic scale. Add, in each case, suitable labeling information.
```{r}
Manitobarow<-c("Winnipeg","Winnipegosis","Manitoba",
"SouthernIndian","Cedar","Island","Gods","Cross","Playgreen")
dotchart(area,labels=Manitobarow)
dotchart(log2(area),labels=Manitobarow)
```

**MB.Ch1.8. ** Using the sum() function, obtain a lower bound for the area of Manitoba covered by water.
```{r}
sum(area)
```